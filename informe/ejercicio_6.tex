\section{Ejercicio 6} 

En este momento contamos con varios algoritmos para resolver el problema de $k$-PMP:
\begin{enumerate}
  \item algoritmo exacto.
  \item algoritmo goloso.
  \item heurísticas de búsqueda local y sus respectivas vecindades \textbf{(a)} swap y \textbf{(b)} jump.
  \item GRASP.
\end{enumerate}
El único de ellos que nos garantiza que la solución obtenida es óptima, exacta en este caso, es el algoritmo exacto.
El resto no exploran todo el espacio de soluciones sino que intentan recorrer un subconjunto acotado del mismo,
guiados por alguna heurística, y extraer la mejor del subconjunto explorado. El algoritmo exacto y el goloso
no requieren de configuración alguna. La búsqueda local y el GRASP sí requieren configuración y por lo tanto
dependiendo de la configuración que se utilice pueden devolver resultados diferentes para la misma instancia.

El objetivo de la siguiente experimentación 

\subsection{Conclusiones}

Discutimos sobre criterios de parada y sobre la selección de candidatos de la golosa aleatorizada, y elegimos una configuración en base a los resultados obtenidos para un primer conjunto de instancias.

Testeamos sobre dos criterios de parada y comentamos sus beneficios y problemas. En una aplicación real, sería conveniente por lo menos usar una combinación de ambos criterios, es decir, iteraciones sin mejora pero con un límite máximo de iteraciones global. Por otro lado, para distintos valores de $n$, vimos que es conveniente variar los límites para reducir el tiempo de ejecución, por lo cual sería interesante tener límites dinámicos según la cantidad de vértices del grafo de entrada.

Para la selección de candidatos de la golosa aleatorizada, testeamos varios niveles de profundidad de elección de vértice y de elección de conjunto. No fue claro en particular que la mejor profundidad sea $(4,4)$, ya que aunque resultó ganadora, los errores relativos eran tan cercanos a cero que bien podría tratarse de una acumulación de los errores de cálculo inherentes a la aritmética finita. Sí es más claro que es más importante aleatorizar la elección del conjunto destino.

%Elegimos la configuración de iteraciones sin mejora y profundidad de elección de vértice-conjunto $(4,4)$ y comparamos los resultados del primer conjunto con un nuevo conjunto de iteraciones. Vimos que aunque los tiempos de ejecución se mantuvieron intactos, la calidad no fue la esperada, teniendo en algunos casos el doble de error relativo para el segundo conjunto. Esto sugiere que no hay garantía de que una configuración funcione relativamente bien siempre, la única garantía de calidad parece ser la cantidad de iteraciones que realiza la GRASP.
